#!/usr/bin/env python3

import os
import re
import argparse
from typing import List
import subprocess

SHELL_SCRIPT = """cat /etc/os-release || cat /usr/lib/os-release; \
echo -n ::; \
uname -sr; \
echo -n ::; \
cat /etc/hostname; \
echo -n ::; \
grep -m 1 "model name" /proc/cpuinfo; \
echo -n ::; \
free -m | grep Mem:; \
echo -n ::; \
cat /sys/devices/virtual/dmi/id/product_name; \
echo -n ::; \
cat /proc/uptime; \
echo -n ::; \
echo -n $SHELL"""


def validate_host(host: str):
    # Several regexes combined from the Internet, it *should* work for all cases
    match = re.match(
        r"^[a-zA-Z0-9]{1,30}@(([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})|((((?!\-))(xn\-\-)?[a-z0-9\-_]{0,61}[a-z0-9]{1,1}\.)*(xn\-\-)?([a-z0-9\-]{1,61}|[a-z0-9\-]{1,30})\.[a-z]{2,}))$", host)
    return bool(match)


def process_ssh_output(ssh_output: str):
    command_outputs = ssh_output.split("::")

    distro, ansi_color = filter_os_release(command_outputs[0])
    kernel = command_outputs[1].strip()
    hostname = command_outputs[2].strip()
    cpu = filter_cpu(command_outputs[3])
    mem_total, mem_avail, mem_used = filter_memory(command_outputs[4])
    system_platform = command_outputs[5].strip()
    uptime = process_uptime(command_outputs[6])
    shell = filter_shell(command_outputs[7])

    return {"distro": str(distro),
            "color": str(ansi_color),
            "kernel": str(kernel),
            "hostname": str(hostname),
            "cpu": str(cpu),
            "mem_total": str(mem_total),
            "mem_avail": str(mem_avail),
            "mem_used": str(mem_used),
            "platform": str(system_platform),
            "uptime": str(uptime),
            "shell": str(shell)}


def filter_os_release(os_release: str):
    result = {}
    for line in os_release.splitlines():
        key, value = line.strip().split("=")
        result[key] = value.strip('"')
    distro = "Linux"
    ansi_color = None

    if result["PRETTY_NAME"]:
        distro = result["PRETTY_NAME"]
    elif result["NAME"]:
        distro = result["NAME"]

    if result["ANSI_COLOR"]:
        ansi_color = result["ANSI_COLOR"]

    return distro, ansi_color


def filter_cpu(cpu_info: str):
    _, cpu = cpu_info.split(": ")
    return cpu.strip()


def filter_memory(memory_info: str):
    _, total_str, used_str, _, _, _, avail_str = memory_info.strip().split()

    total_mib = int(total_str)
    used_mib = int(used_str)
    avail_mib = int(avail_str)

    return total_mib, avail_mib, used_mib


def process_uptime(uptime_str: str):
    # Uptime comes in the format: <UPTIME> <IDLE_TIME>
    # This strips the newline from the end, splits the uptime and idle time, and returns the first element (just the uptime)
    ut = float(uptime_str.strip().split()[0])
    result = f"up {int(ut // 60 // 60 // 24)} days, {int(ut // 60 // 60 % 24)} hours, and {int(ut // 60 % 60)} minutes"
    return result


def filter_shell(shell: str):
    return os.path.basename(shell)


def render(machines: List):
    for machine in machines:
        pass


def main():
    parser = argparse.ArgumentParser(
        description="A fetch tool to get and display homelab information using SSH")
    parser.add_argument("-t", "--target", help="A target to fetch (username@host)",
                        type=str, action="append", required=True)
    args = parser.parse_args()

    targets: List[str] = args.target
    for target in targets:
        if not validate_host(target):
            print(f"{target} is not a valid SSH connection string")
            exit(1)

    machines = []

    for target in targets:
        ssh_output = subprocess.run(
            args=["ssh", target, f"sh -c '{SHELL_SCRIPT}'"], capture_output=True).stdout.decode()
        machine_info = process_ssh_output(ssh_output)
        machine_info["ssh_string"] = target
        machines.append(machine_info)


if __name__ == "__main__":
    main()
